{"meta":{"title":"Eat your own dogfood","subtitle":"皇家认证特级搜救犬","description":"Altharsbuzhihuo's blog","author":"Altharsbuzhihuo","url":"http://Altharsbuzhihuo.com"},"pages":[{"title":"categories","date":"2018-05-26T07:05:54.000Z","updated":"2018-05-26T07:06:43.366Z","comments":true,"path":"categories/index.html","permalink":"http://Altharsbuzhihuo.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-26T07:02:08.000Z","updated":"2018-05-26T07:03:50.652Z","comments":true,"path":"tags/index.html","permalink":"http://Altharsbuzhihuo.com/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2018-05-26T08:09:37.000Z","updated":"2018-07-13T09:18:14.481Z","comments":true,"path":"page/关于我.html","permalink":"http://Altharsbuzhihuo.com/page/关于我.html","excerpt":"","text":"关于我皇家认证特级搜救犬混吃等死狗欢迎光临本小破站。 只要你主动，我们就会有故事。 我的联系方式：wechat：berlin1953v Email：tianranv@foxmail.com"}],"posts":[{"title":"二分歸并排序（Java實現）","slug":"二分歸并排序（Java實現）","date":"2018-07-13T06:49:07.000Z","updated":"2018-07-13T06:57:55.634Z","comments":true,"path":"2018/07/13/二分歸并排序（Java實現）/","link":"","permalink":"http://Altharsbuzhihuo.com/2018/07/13/二分歸并排序（Java實現）/","excerpt":"","text":"二分歸并排序 将数组从中切开分为一半，然后分区再继续划分子区间，直到分为只有两个元素比较或单个元素的无数个小区间。比较完各个分区两个元素大小之后，再将区间重新两两合并，合并过程中保持顺序由大到小排列。 时间复杂度：O(log₂n)空间复杂度：O(1) 123456789101112131415161718192021222324252627282930313233343536public void mergeSort(int[] arrays) &#123; int low,mid,high,base; for(int i=1;i&lt;arrays.length;i++) &#123; low=0; high=i-1; base=arrays[i]; while(low&lt;=high) &#123; mid=(low+high)/2; if(arrays[mid]&gt;base) &#123; low=mid+1; &#125; else if(arrays[mid]&lt;base) &#123; high=mid-1; &#125; &#125; for(int j=i-1;j&gt;=high+1;j--) &#123; arrays[j+1]=arrays[j]; &#125; arrays[high+1]=base; &#125; //依次打印排序后得到的结果 System.out.print(\"二分归并排序结果如下：\"); for(int i=0;i&lt;arrays.length;i++) &#123; System.out.print(arrays[i]+\" \"); &#125; System.out.print(\"\\n\"); &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/tags/数据结构/"},{"name":"二分歸并排序","slug":"二分歸并排序","permalink":"http://Altharsbuzhihuo.com/tags/二分歸并排序/"},{"name":"Java","slug":"Java","permalink":"http://Altharsbuzhihuo.com/tags/Java/"}]},{"title":"堆排序（Java实现）","slug":"堆排序（Java实现）","date":"2018-06-15T00:46:37.000Z","updated":"2018-07-13T06:42:34.492Z","comments":true,"path":"2018/06/15/堆排序（Java实现）/","link":"","permalink":"http://Altharsbuzhihuo.com/2018/06/15/堆排序（Java实现）/","excerpt":"","text":"堆排序 时间复杂度：(nlogn)空间复杂度：空间复杂度：O(1) 來不及解釋了，看代碼： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 重建堆（这里为最大堆） * 将数组处理为完全二叉树，使父结点&gt;左孩子&gt;右孩子 * 自下而上调整二叉树结点位置，根节点为数组最大值 * @param arrays 被排序数组 * @param n 数组长度 * @param h 非叶结点下标i */ public void CreateHeap(int[] arrays,int n,int h) &#123; //将非叶结点下标赋给i，定义叶子结点j int i=h; int j=2*i+1; //设置标志位flag为false boolean flag=false; int temp=arrays[i]; //查找左右孩子最大结点并交换到父结点 while(j&lt;n&amp;&amp;!flag)&#123; //如果左孩子小于右孩子就j++指向右孩子 if(j&lt;n-1&amp;&amp;arrays[j]&lt;arrays[j+1])j++; //如果父结点大于右孩子，则flag=true，本次循环结束 if(temp&gt;arrays[j]) &#123; flag=true; &#125; //否则将右孩子放入父结点 else &#123; arrays[i]=arrays[j]; i=j; j=2*i+1; &#125; &#125; //给子结点放入原父结点的值 arrays[i]=temp; &#125; /** * 堆排序 * @param arrays */ public void HeapSort(int[] arrays) &#123; //n为数组下标最后一位 int n=arrays.length-1; int temp=0; initHeap(arrays); //从小到大循环依次从堆中取出结点 for(int i=n;i&gt;0;i--) &#123; temp=arrays[0]; arrays[0]=arrays[i]; arrays[i]=temp; CreateHeap(arrays,i,0); &#125; //依次打印排序后得到的结果 System.out.print(\"堆排序结果如下：\"); for(int i=0;i&lt;=n;i++) &#123; System.out.print(arrays[i]+\" \"); &#125; System.out.print(\"\\n\"); &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/tags/数据结构/"},{"name":"Java","slug":"Java","permalink":"http://Altharsbuzhihuo.com/tags/Java/"},{"name":"堆排序","slug":"堆排序","permalink":"http://Altharsbuzhihuo.com/tags/堆排序/"}]},{"title":"快速排序（Java实现）","slug":"快速排序（Java实现）","date":"2018-06-06T11:40:35.000Z","updated":"2018-06-06T13:45:22.904Z","comments":true,"path":"2018/06/06/快速排序（Java实现）/","link":"","permalink":"http://Altharsbuzhihuo.com/2018/06/06/快速排序（Java实现）/","excerpt":"","text":"快速排序1.选择一个基准数x为arrays[0]，先从最右往左开始查找比x小的第一个数，找到后与arrays[i]交换位置。2.再从左往右开始查找比x大的第一个数，找到后再与arrays[j]交换位置。3.然后再重复1，2步骤，直到将数组中的数以x为基准分好区，此时i=j，将基准数x归位到arrays[i],左边的数都比x小，右边的数都比x大。4.以x为界形成两个子区间，然后分别进行递归，也就是重复以上步骤就排好了。 时间复杂度：平均为O(nlogn),最好为O(nlogn)，最坏为O(n2)空间复杂度：O(log₂n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 快速排序 * @param arrays 被排序数组 * @param l 区间最左边的下标 * @param r 区间最右边的下标 */ public void quickSort(int[] arrays,int l,int r) &#123; if(l&gt;r) &#123; return; &#125; //给i赋值为区间最左下标，给j赋值为区间最右下标 int i=l,j=r,x=arrays[i]; //以基准数x为标准，对数组的数进行分区，直到i==j，循环结束 while(i&lt;j) &#123; //从右往左循环查找比基准数小的数arrays[j]，并填入arrays[i]中 while(arrays[j]&gt;=x&amp;&amp;i&lt;j)j--; if(i&lt;j) &#123; arrays[i++]=arrays[j]; &#125; //从左往右循环查找比基准数大的数arrays[i]，并填入arrays[j]中 while(arrays[i]&lt;=x&amp;&amp;i&lt;j)i++; if(i&lt;j) &#123; arrays[j--]=arrays[i]; &#125; &#125; //此时i==j,将基准数x归位，使x左边的数都比x小，x右边的数都比x大 arrays[i]=x; //进行递归，将左右分区继续排序 if(l&lt;i)quickSort(arrays,l,i-1); if(r&gt;i)quickSort(arrays,i+1,r); &#125; /** * 给quicSort传递参数，最左下标为0，最右下标为数组长度减1 * @param a 被排序数组 */ public void QuickSort(int[] a) &#123; quickSort(a,0,a.length-1); //依次打印排序后得到的结果 System.out.print(\"快速排序结果如下：\"); for(int i=0;i&lt;a.length;i++) &#123; System.out.print(a[i]+\" \"); &#125; System.out.print(\"\\n\"); &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/tags/数据结构/"},{"name":"Java","slug":"Java","permalink":"http://Altharsbuzhihuo.com/tags/Java/"},{"name":"快速排序","slug":"快速排序","permalink":"http://Altharsbuzhihuo.com/tags/快速排序/"}]},{"title":"简单排序之冒泡排序、选择排序、插入排序（Java实现）","slug":"简单排序之冒泡排序、选择排序、插入排序（Java实现）","date":"2018-06-01T12:28:23.000Z","updated":"2018-06-06T13:02:02.975Z","comments":true,"path":"2018/06/01/简单排序之冒泡排序、选择排序、插入排序（Java实现）/","link":"","permalink":"http://Altharsbuzhihuo.com/2018/06/01/简单排序之冒泡排序、选择排序、插入排序（Java实现）/","excerpt":"","text":"今天写了一下数据结构里三种比较基础简单的排序算法。 1.冒泡排序升序的话就是，两两依次比较，然后把大的数往后沉下去，第一次排序结束，最后一个最大的数优先排好，然后进行第二次比较，如果数组长度为n，那么一共要进行n次比较，每一次进行n-i-1趟比较。 代码如下： 123456789101112131415161718192021222324public void bubbleSort(int[] arrays) &#123; int n=arrays.length; int temp=0; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n-i-1;j++) &#123; if(arrays[j]&gt;arrays[j+1]) &#123; temp=arrays[j+1]; arrays[j+1]=arrays[j]; arrays[j]=temp; &#125; &#125; &#125; //依次打印排序后得到的结果 System.out.print(\"冒泡排序结果如下：\"); for(int i=0;i&lt;n;i++) &#123; System.out.print(arrays[i]+\" \"); &#125; System.out.print(\"\\n\"); &#125; 时间复杂度:O(n²)空间复杂度:O(1) 2.选择排序同样也是升序，就是从数组下标0开始，依次比较，第一次比较出最小的数，和arrays[0]交换位置，然后依次类推，找出剩余最小的数，交换位置，如果数组长度为n，那么一共要进行n次比较，每一次比较n-i趟。 代码如下： 123456789101112131415161718192021222324252627public void selectSort(int[] arrays) &#123; int n=arrays.length; int temp=0; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n-i;j++) &#123; if(arrays[i]&gt;arrays[i+j]) &#123; temp=arrays[i]; arrays[i]=arrays[i+j]; arrays[i+j]=temp; &#125; &#125; &#125; //依次打印排序后得到的结果 System.out.print(\"选择排序结果如下：\"); for(int i=0;i&lt;n;i++) &#123; System.out.print(arrays[i]+\" \"); &#125; System.out.print(\"\\n\"); &#125; 时间复杂度:O(n²)空间复杂度:O(1) 3.插入排序升序，假定一个数组从arrays[0]开始，然后往里面依次插入数，保证每次插入的数顺序都已经排好。每当要插入arrays[j]时，从已排好序的数组的下标最后一位开始扫描，如果arrays[j]之前还有比它大的数就交换位置。如果数组长度为n，一共要比较n次，一共比较0+1+2+…+n-1次。 代码如下： 12345678910111213141516171819202122232425262728 public void insertSort(int[] arrays) &#123; int n=arrays.length; int temp=0; for(int i=0;i&lt;n;i++) &#123; for(int j=i;j&gt;0;j--) &#123; if(arrays[j-1]&gt;arrays[j]) &#123; temp=arrays[j-1]; arrays[j-1]=arrays[j]; arrays[j]=temp; &#125; &#125; &#125; //依次打印排序后得到的结果 System.out.print(\"插入排序结果如下：\"); for(int i=0;i&lt;n;i++) &#123; System.out.print(arrays[i]+\" \"); &#125; System.out.print(\"\\n\");&#125; 时间复杂度:O(n²)空间复杂度:O(1)","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/tags/数据结构/"},{"name":"Java","slug":"Java","permalink":"http://Altharsbuzhihuo.com/tags/Java/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"http://Altharsbuzhihuo.com/tags/冒泡排序/"},{"name":"选择排序","slug":"选择排序","permalink":"http://Altharsbuzhihuo.com/tags/选择排序/"},{"name":"插入排序","slug":"插入排序","permalink":"http://Altharsbuzhihuo.com/tags/插入排序/"}]},{"title":"字符串模式匹配算法（Java实现）","slug":"字符串模式匹配算法（Java实现）","date":"2018-05-31T06:58:45.000Z","updated":"2018-06-06T13:03:29.248Z","comments":true,"path":"2018/05/31/字符串模式匹配算法（Java实现）/","link":"","permalink":"http://Altharsbuzhihuo.com/2018/05/31/字符串模式匹配算法（Java实现）/","excerpt":"","text":"1.BF算法暴风(Brute Force)算法，又叫朴素算法,是一种比较好理解的简单字符串匹配算法。它是一种带回溯的模式匹配算法，将目标串依次逐字与模式串比较，再将得到的匹配结果输出。 代码如下：1234567891011121314151617181920212223242526public void searchAll(String str1,String str2)&#123; int i=0,j=0; int len1=str1.length(); int len2=str2.length(); //外层循环遍历目标字符串 for(i=0;i&lt;len1;i++)&#123; //内层循环遍历模式串 for(j=0;j&lt;len2;j++)&#123; //逐字比较是否一致，不一致则break结束内层循环 if(str1.charAt(i+j)!=str2.charAt(j)) &#123; break; &#125; //打印得到的匹配结果 else if(j==len-1) &#123; System.out.println(\"子串出现的位置为：\"+i); &#125; &#125; &#125; &#125; 时间复杂度： m=str1.length();n=str2.length(); 最好的情况：O(m)最坏的情况：O(n(n-m+1)m) 2.KMP算法有点复杂，还没写，以后再写","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/tags/数据结构/"},{"name":"Java","slug":"Java","permalink":"http://Altharsbuzhihuo.com/tags/Java/"},{"name":"模式匹配","slug":"模式匹配","permalink":"http://Altharsbuzhihuo.com/tags/模式匹配/"},{"name":"BF算法","slug":"BF算法","permalink":"http://Altharsbuzhihuo.com/tags/BF算法/"},{"name":"KMP算法","slug":"KMP算法","permalink":"http://Altharsbuzhihuo.com/tags/KMP算法/"}]}]}