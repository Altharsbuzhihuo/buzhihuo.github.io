{"meta":{"title":"Eat your own dogfood","subtitle":"皇家认证特级搜救犬","description":"Altharsbuzhihuo's blog","author":"Altharsbuzhihuo","url":"http://Altharsbuzhihuo.com"},"pages":[{"title":"categories","date":"2018-05-26T07:05:54.000Z","updated":"2018-05-26T07:06:43.366Z","comments":true,"path":"categories/index.html","permalink":"http://Altharsbuzhihuo.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-26T07:02:08.000Z","updated":"2018-05-26T07:03:50.652Z","comments":true,"path":"tags/index.html","permalink":"http://Altharsbuzhihuo.com/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2018-05-26T08:09:37.000Z","updated":"2018-07-13T09:18:14.481Z","comments":true,"path":"page/关于我.html","permalink":"http://Altharsbuzhihuo.com/page/关于我.html","excerpt":"","text":"关于我皇家认证特级搜救犬混吃等死狗欢迎光临本小破站。 只要你主动，我们就会有故事。 我的联系方式：wechat：berlin1953v Email：tianranv@foxmail.com"}],"posts":[{"title":"JDBC","slug":"JDBC","date":"2018-08-03T03:05:54.000Z","updated":"2018-08-03T03:07:51.587Z","comments":true,"path":"2018/08/03/JDBC/","link":"","permalink":"http://Altharsbuzhihuo.com/2018/08/03/JDBC/","excerpt":"","text":"JDBC(Java DataBase Connection)程序的创建步骤：1.加载JDBC驱动程序Class.forName(com.mysql.jdbc.Driver) 2.提供JDBC连接的URLString url=&quot;jdbc:mysql://localhost:3306/db_shop&quot;; String username=&quot;root&quot;; String password=&quot;root&quot;; 3.创建数据库连接Connedtion conn=DriverManager.getConnection(url,username,password); 4.创建一个StatementStatement stmt=conn.createStatement(); 5.执行SQL语句String sql=&quot;select * from user&quot;; ResultSet rs=stmt.executeQuery(sql); 6.处理结果try{ int id=rs.getInt(&quot;id&quot;); String name=rs.getString(&quot;username&quot;); String psw=rs.getString(&quot;password&quot;); }catch(ClassNotFoundException e){ e.printStackTrace(); } 7.关闭JDBC对象try{ rs.close(); rs=null; stmt.close(); stmt=null; conn.close(); conn=null; }catch(SQLException e){ e.printStackTrace(); } 完整的程序import java.mysql.*; public class JDBCExample01{ public static void main(String[] args) throws SQLException, ClassNotFoundException { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); String url=&quot;jdbc:mysql://localhost:3306/db_shop&quot;; String username=&quot;root&quot;; String password=&quot;root&quot;; Connection conn = DriverManager.getConnection(url, username, password); Statement stmt=conn.createStatement(); String sql=&quot;select * from users&quot;; ResultSet rs=stmt.executeQuery(sql); System.out.println(rs.getString(&quot;id&quot;)); System.out.println(rs.getString(&quot;username&quot;)); System.out.println(rs.getString(&quot;password&quot;)); rs.close(); rs=null; stmt.close(); stmt=null; conn.close(); conn=null; } } 使用prepareStatement类import java.sql.*; public class Example{ public void static main(String[] args) throw SQLException{ Class.forName(&quot;com.mysql.jdbc.Driver&quot;); String url=&quot;jdbc:mysql://localhost:3306/db_shop&quot;; String username=&quot;root&quot;; String password=&quot;root&quot;; conn=DriverManager.getConnection(url,username,password); String sql=&quot;INSERT INTO user(name,password,email)&quot;+&quot;VALUE(?,?,?)&quot;; preStmt=conn.PrepareStatement(sql); preStmt=setString(1,&quot;zl&quot;); preStmt=setString(2,&quot;12345&quot;); preStmt=setString(3,&quot;zl@foxmain.com&quot;); preStmt.executeUpdate(); preStmt.close(); preStmt=null; conn.close(); conn=null; } }","categories":[{"name":"笔记","slug":"笔记","permalink":"http://Altharsbuzhihuo.com/categories/笔记/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://Altharsbuzhihuo.com/tags/笔记/"},{"name":"javaweb","slug":"javaweb","permalink":"http://Altharsbuzhihuo.com/tags/javaweb/"},{"name":"JDBC","slug":"JDBC","permalink":"http://Altharsbuzhihuo.com/tags/JDBC/"}]},{"title":"Jsp","slug":"Jsp","date":"2018-07-29T12:46:20.000Z","updated":"2018-07-29T12:56:18.079Z","comments":true,"path":"2018/07/29/Jsp/","link":"","permalink":"http://Altharsbuzhihuo.com/2018/07/29/Jsp/","excerpt":"","text":"JspJsp只是servlet的一个变种，为了方便书写html内容才出现。servlet是根本，所有jsp能做的，servlet全能做。 Jsp与Js的区别JS是在客户端执行的，需要浏览器支持Javascript。JSP是在服务器端执行的，需要服务器上部署支持Servlet的服务器程序。JS代码是能够直接从服务器上download得到，对外是可见的，jsp(和翻译后的servlet)代码是对外不可见的。JS与JavaScript相比：虽然JavaScript可以在客户端动态生成HTML，但是很难与服务器交互，因此不能提供复杂的服务，比如访问数据库和图像处理等等。JSP在HTML中用&lt;%%&gt;里面实现。JS在html中用实现。 Jsp的生命周期JSP生命周期就是从创建到销毁的整个过程，类似于servlet生命周期，区别在于JSP生命周期还包括将JSP文件编译成servlet。 以下是JSP生命周期中所走过的几个阶段： 编译阶段：servlet容器编译servlet源文件，生成servlet类 初始化阶段：加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法 执行阶段：调用与JSP对应的servlet实例的服务方法 执行阶段：调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例 Jsp指令#定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等 &lt;%@page...%&gt; #包含其他文件 &lt;%@include...%&gt; #引入标签库的定义，可以是自定义标签 &lt;%@taglib...%&gt; Jsp四个作用域(page&lt; request &lt; session &lt; application)所谓作用域，规定的是变量的有效期限。 page有效范围只在当前jsp页面。 request有效范围是当前请求周期。 session有效范围是当前会话。 所谓当前会话，就是指从用户打开浏览器开始，到用户关闭浏览器这中间的过程。也就是说，只要用户不关闭浏览器，服务器就有办法知道这些请求是一个人发起的，整个过程被称为一个会话(session)，而放入会话里的所有变量，就可以在当前所有请求中使用。 application有效范围是整个应用。 整个应用是指从应用启动，到应用结束。一个服务器可能部署多个应用，当然你关闭了服务器，就会把上面所有的应用都关闭了。 与上述三个不同的是，application里的变量可以被所有用户共用。如果用户甲的操作修改了application中的变量，用户乙访问时得到的是修改后的值。这在其他scope中都是不会发生的，page, request,session都是完全隔离的，无论如何修改都不会影响其他人的数据。 Jsp九个内置对象 内置对象 类型 作用域 描述 request 请求对象 Request HttpServletRequest类的实例 response 响应对象 Page HttpServletResponse类的实例 pageContext 页面上下文对象 Page PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问 session 会话对象 Session HttpSession类的实例 application 应用程序对象 Application ServletContext类的实例，与应用上下文有关 out 输出对象 Page PrintWriter类的实例，用于把结果输出至网页上 config 配置对象 Page ServletConfig类的实例 page 页面对象 Page 类似于Java类中的this关键字 exception 例外对象 Page Exception类的对象，代表发生错误的JSP页面中对应的异常对象 Jsp的七个动作指令1）jsp:include 指令用于请求处理阶段包含一个servlet或jsp页面的响应。和编译指令中的include不同，include只能包含静态页面，而jsp:include指令可以包含静态和动态页面。 #静态页面 &lt;jsp:include page=&quot;文件路径&quot;/&gt; #动态页面 &lt;jsp:include page=&quot;文件路径&quot;&gt; ... &lt;/jsp:include&gt; 2)jsp:forword指令用于执行页面转向，将请求的处理转发到下一页面。 #跳转向静态页面 &lt;jsp:forword page=&quot;文件路径&quot;/&gt; #跳转向动态页面 &lt;jsp:forword page=&quot;文件路径&quot;&gt; ... &lt;/jsp:forword&gt; 3)jsp:useBean指令用于在jsp页面内创建一个JavaBean实例。 &lt;jsp:userBean id=&quot;JavaBean的名字&quot; scope=&quot;有效范围&quot; class=&quot;包名.类名&quot;&gt;&lt;jsp:userBean&gt; 4)jsp:setProparty指令用来设置Bean对象的属性 &lt;jsp:setProparty name=&quot;JavaBean的名称&quot; proparty=&quot;属性名&quot;/&gt; &lt;jsp:setProparty name=&quot;JavaBean的名称&quot; proparty=&quot;属性名&quot; param=&quot;参数名&quot;/&gt; &lt;jsp:setProparty name=&quot;JavaBean的名称&quot; proparty=&quot;属性名&quot; value=&quot;参数名&quot;/&gt; 5)jsp:getProparty指令用来读取Bean对象的属性，并将其转换为一个字符串显示在页面上。 &lt;jsp:getProparty name=&quot;Bean的名称&quot; proparty=&quot;属性名称&quot;&gt; 6)jsp:plugin指令（不常用）用于下载服务器端的JavaBean或Applet到客户端执行。 7）jsp:param指令（不常用）用于设置参数，不能单独使用，主要用在jsp:inclde jsp:forword jsp:plugin指令中。 include指令与include动作1）include指令：include可以在JSP页面转换成Servlet之前，将JSP代码插入其中。它的主要优点是功能强大，所包含的代码可以含有总体上影响主页面的JSP构造，比如属性、方法的定义和文档类型的设定。它的缺点是难于维护只要被包含的页面发生更改，就得更改主页面，这是因为主页面不会自动地查看被包含的页面是否发生更改。include指令的语法格式如下： &lt;%@include file=&quot;Relative Url&quot;%&gt; 2）include动作：jsp:include动作是在主页面被请求时，将次级页面的输出包含进来。尽管被包含的页面的输出中不能含有JSP，但这些页面可以是其他资源所产生的结果。服务器按照正常的方式对指向被包含资源的URL进行解释，因而这个URL可以是Servlet或JSP页面。服务器以通常的方式运行被包含的页面，将产生的输出放到主页面中，这种方式与RequestDispatcher类的include方法一致。它的优点是在被包含的页面发生更改时，无须对主页面做出修改。它的缺点是所包含的是次级页面的输出，而非次级页面的实际代码，所以在被包含的页面中不能使用任何有可能在整体上影响主页面的JSP构造。jsp:include动作的完整语法如下： &lt;jsp:include page=&quot;Relative path to resource&quot; flush=&quot;true&quot;&gt; 两者区别：jsp:include动作和include指令之间的根本性的不同在于它们被调用的时间。jsp:include动作在请求期间被激活，而include指令在页面转换期间被激活。 两者之间的差异决定着它们在使用上的区别。使用include指令的页面要比使用jsp:include动作的页面难于维护。使用JSP指令，如果包含的JSP页面发生变化，那么用到这个页面的所有页面都需要手动更新。在JSP服务器的相关规范中并没要求能够检测出包含的文件什么时候发生改变，实际上大多数服务器页都有去实现这种机制。这样就会导致十分严重的维护问题，需要记住所有包含某一个页面的其他页面，或者重新编译所有的页面，以使更改能够生效。在这点上，jsp:include就体现出了十分巨大的优势，它在每次请求时重新把资源包含进来。在实现文件包含上，应该尽可能地使用jsp:include动作。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://Altharsbuzhihuo.com/categories/笔记/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://Altharsbuzhihuo.com/tags/笔记/"},{"name":"javaweb","slug":"javaweb","permalink":"http://Altharsbuzhihuo.com/tags/javaweb/"},{"name":"Jsp","slug":"Jsp","permalink":"http://Altharsbuzhihuo.com/tags/Jsp/"}]},{"title":"Servlet","slug":"Servlet","date":"2018-07-19T01:56:44.000Z","updated":"2018-07-19T02:08:53.833Z","comments":true,"path":"2018/07/19/Servlet/","link":"","permalink":"http://Altharsbuzhihuo.com/2018/07/19/Servlet/","excerpt":"","text":"什么是Servlet？Servlet是一个Java程序，在服务器上运行以处理客户端请求并做出响应的程序。Servlet主要用于处 理客户端传来的HTTP请求，并返回一个响应，它能够处理的请求有 doGet()和doPost()等方法。Servlet由Servlet容器提供，所谓的Servlet容器是指提供了Servlet 功能的 服务器（本书中指Tomcat），Servlet容器将Servlet动态的加载到服务器 上。与HTTP 协议相关的Servlet使用HTTP请求和HTTP响应与客户端进行交互。因此，Servlet容器支持所有HTTP协议的请求和响应。 servlet的创建方式（三种）1.继承HttpServlet类实现一个自定义servlet[有http特性]2.通过实现Servlet接口实现一个自定义servlet[什么特性都没有，所有实现要自己写]3.继承GenericServlet抽象类实现一个自定义servlet[通过继承该抽象类实现类似于https特性的请求和响应] Servlet的配置方式（两种）1.基于XML的配置，在web.xml中通过servlet节点配置 &lt;servlet&gt; &lt;servlet-name&gt;secondServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;cx.servlet.SecondServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;-1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;secondServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/hstt.php&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 2.基于注解的配置（servlet3.0版本以上） @WebServlet(name = &quot;SimpleServlet&quot;,urlPatterns = {&quot;/simple.jsp&quot;}) servlet容器：运行servlet、JSP、Filter等软件环境1.可以来创建servlet，并调用servlet的相关生命周期方法。2.JSP，Filter，Listener，Tag… servlet生命周期方法1.构造器：只有第一次请求servlet时，创建servlet的实例，调用构造器（只被调用一次）。这说明servlet是单例的。2.init方法：只被调用一次，在创建好实例后立即被调用，用于初始化当前servlet。3.service：处理具体的请求返回响应，在具体子类中转交给了doGet方法或doPost方法。4.destory：只被调用一次，在当前servlet所在的web应用被卸载前调用，用于释放当前servlet所占用资源。 load-on-startup参数1.配置在web.xml的servlet节点中或者注解配置。servlet节点 &lt;servlet&gt; &lt;servlet-name&gt;secondServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;cx.servlet.SecondServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;-1&lt;/load-on-startup&gt; &lt;/servlet&gt; 注解 @WebServlet( loadOnStartup = 1, urlPatterns = {&quot;/si.do&quot;,&quot;/servletTest.jsp&quot;}) 一个servlet类可用配置多个url映射，而且注解的配置和xml配置可用配置到同一个servlet类上。 2.load-on-startup：可以指定servlet被创建的时机。若为负数，则在第一次请求时被创建。若为0或负数，则在当前web应用被servlet容器加载时创建实例，且数据越小越早被创建。 关于servlet-mapping一个servlet可以对应多个servlet-mapping 虚拟路径：“.扩展名”，”/“ 合法 注意：/*.action不合法 ServletConfig封装了servlet的配置信息，并且可以获取servletContext对象1.配置servlet初始化参数 &lt;init-param&gt; &lt;param-name&gt;user&lt;/param-name&gt; &lt;param-value&gt;root&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;123&lt;/param-value&gt; &lt;/init-param&gt; 该节点必须在load-on-startup节点之前 2.获取初始化参数：配置初始化参数的两种方式：web.xml &lt;context-param&gt; &lt;param-name&gt;driver&lt;/param-name&gt; &lt;param-value&gt;com.mysql.jdbc.Driver&lt;/param-value&gt; &lt;/context-param&gt; 注解 @WebServlet{ urlPatterns={&quot;/hello.do&quot;}, initParams={@WebInitParam(name = &quot;code&quot;,value = &quot;UTF-8&quot;) } } getInitParameter(String name):获取指定参数名的初始化参数getInitParameterNames():获取参数名组成的Enumeration对象 ServletContext通过ServletContext接口读取 上下文参数（用于多个servlet间共享配置和数据） 1.可以由ServletConfig获取servletContext对象 ServletContext servletContext=servletConfig.getServletContext(); 2.ServletContext是当前web应用的一个大管家，可以获取到当前web应用的各方面信息。 获取当前web应用的初始化参数 设置上下文参数（context-param可以为所有Servlet所获取，而Servlet的初始化参数init-param只给那个Servlet可以获取） &lt;context-param&gt; &lt;param-name&gt;driver&lt;/param-name&gt; &lt;param-value&gt;com.mysql.jdbc.Driver&lt;/param-value&gt; &lt;/context-param&gt; ##获取当前web应用的某一个文件的路径得到的返回结果为在服务器上的绝对路径，而不是部署前的路径 getRealPath(String path) ServletContext servletContext=this.getServletContext(); String contextInit= servletContext.getInitParameter(&quot;coding&quot;); System.out.println(&quot;读取到上下文的配置参数值：&quot;+contextInit); servletContext.setAttribute(&quot;gkey&quot;,&quot;全局共享的数据&quot;); System.out.println(&quot;上下文的属性数据：&quot;+servletContext.getAttribute(&quot;gkey&quot;)); String realPath=servletContext.getRealPath(&quot;WEB-INF/classes/cx.properties&quot;); FileInputStream in=new FileInputStream(realPath); Properties ppt=new Properties(); ppt.load(in); System.out.println(ppt.getProperty(&quot;Company&quot;)); System.out.println(ppt.getProperty(&quot;Address&quot;)); ##获取当前web应用的名称 getContextPath() ##获取当前web应用的某一个文件对应的输入流 getResourceAsStream(String path) path–&gt; ‘/‘相当于当前web的根目录 Get请求和Post请求1.Get请求传参在url，Get方式传送的数据量一般限制在1KB以下。2.Post请求方式主要用于向web服务器端程序提交form表单中的数据，form中metho置为post。Post方式将各个表单字段及其数据作为HTTP消息实体内容发送给web服务器，传送数据量比get大得多。 如何在Servlet中获得请求信息？1.servlet的service()方法,每次请求都会调用service方法。 ServletRequest：封装了请求信息，可以从中获取任何的请求信息。ServletResponse：封装了响应信息，如果想给用户什么响应，具体可以使用该接口方法实现。这两个接口的实现类都是服务器予以实现的。 获得请求参数 String user=request.getParameter(“user”) 获得当前servlet的刷新次数12345678910111213141516171819202122232425public class OnlineNumberServlet extends HttpServlet &#123; public void init()throws ServletException&#123; //设置初始化参数 ServletContext servletContext=this.getServletContext(); servletContext.setAttribute(&quot;num&quot;,1); System.out.println(&quot;当前servlet的访问次数：&quot;+1); super.init(); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //每刷新一次就将访问数量+1 ServletContext servletContext=this.getServletContext(); Integer val=(Integer) servletContext.getAttribute(&quot;num&quot;); val++; servletContext.setAttribute(&quot;num&quot;,val); System.out.println(&quot;当前本servlet访问次数：&quot;+val+&quot;&quot;); response.setCharacterEncoding(&quot;GBK&quot;); response.getWriter().println(&quot;当前本servlet访问次数：&quot;+val+&quot;&quot;); &#125;&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://Altharsbuzhihuo.com/categories/笔记/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://Altharsbuzhihuo.com/tags/笔记/"},{"name":"javaweb","slug":"javaweb","permalink":"http://Altharsbuzhihuo.com/tags/javaweb/"},{"name":"Servlet","slug":"Servlet","permalink":"http://Altharsbuzhihuo.com/tags/Servlet/"}]},{"title":"搭建个人博客，Hexo+Github","slug":"搭建个人博客，Hexo+Github","date":"2018-07-16T01:43:57.000Z","updated":"2018-07-16T16:53:27.996Z","comments":true,"path":"2018/07/16/搭建个人博客，Hexo+Github/","link":"","permalink":"http://Altharsbuzhihuo.com/2018/07/16/搭建个人博客，Hexo+Github/","excerpt":"","text":"准备工作为什么要用Hexo+Github自建博客？自己建的博客有完全的自主权，你可以自己做各种程序上的修改，完整的备份等等～微软这么大的博客系统都可以一夜之间关掉，你还敢用吗？当然是因为Hexo简单，开源，不要钱，可以为所欲为啊。 什么是Hexo？Hexo官方文档Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 环境安装1.配置Github首先注册/登录Github，看不懂英语，用谷歌浏览器可以翻译网页。 github网址记住自己的username和注册邮箱 选择Create a new repository新建一个仓库 Repository name（填自己的名字） name.github.io(name与你的注册用户名一致,这个就是你博客的域名了) eg:我的域名是github.com/Altharsbuzhihuo，就填入Altharsbuzhihuo.github.io。成功后出现下面的画面: 2.安装 Node.js Node.js安装地址 3.安装 Git Git安装地址Git教程 4.安装完成后,鼠标右键选择–&gt;Git Bash here 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。 5.安装Hexo使用cmd命令窗口输入如下命令： npm install -g hexo-cli 等待下载，成功后输入 npm -v 会显示版本 设置在电脑F盘或者随意什么目录下新建文件test，进入test按住shift点击鼠标右键打开命令行窗口，输入：1hexo init blog 等待下载成功提示：1INFO Start blogging with Hexo! 因为初始化hexo之后source目录下自带一篇hello world文章, 所以直接执行下方命令:1234567#发布草稿，生成预览$ hexo g#启动本地服务器$ hexo s#提示信息INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 访问 http://localhost:4000/， 可以看到网站的初步样子。 重新打开CMD，输入： 1ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot; 一直Enter，得到信息：1Your public key has been saved in /c/Users/user/.ssh/id_rsa.pub. 找到该文件，打开（sublime text），Ctrl + a复制里面的所有内容，然后进入Sign in to GitHub：https://github.com/settings/ssh New SSH key ——Title：blog —— Key：输入刚才复制的—— Add SSH key 设置博客在blog目录下，打开_config.yml文件，修改参数信息。 每个参数后使用一个英文空格 发表文章123# 测试文章$ hexo new &quot;test&quot;INFO Created: E:\\Git\\workspace\\test\\blog\\source\\_posts\\test.md 根据文件路径找到该文章，使用markdown编辑语法。12345---title: testdate: 2018-07-17 00:20:54---这是一篇测试文章。 保存，然后执行如下步骤：12345678910111213141516F:\\test\\blog$ hexo cleanINFO Deleted database.INFO Deleted public folder.F:\\test\\blog$ hexo gINFO Start processingINFO Files loaded in 1.48 s#省略INFO 29 files generated in 4.27 sF:\\test\\blog$ hexo sINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 这个时候，打开http://localhost:4000/ ，发现刚才的文章已经成功了 最后一步，部署发布，执行：12F:\\test\\blog$ hexo d 打开博客链接 https://Altharsbuzhihuo.github.io 就能看到发布了。 相关链接：Hexo的next主题个性化教程","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"http://Altharsbuzhihuo.com/categories/搭建博客/"}],"tags":[{"name":"搭建博客","slug":"搭建博客","permalink":"http://Altharsbuzhihuo.com/tags/搭建博客/"},{"name":"Hexo","slug":"Hexo","permalink":"http://Altharsbuzhihuo.com/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"http://Altharsbuzhihuo.com/tags/Github/"}]},{"title":"二分歸并排序（Java實現）","slug":"二分歸并排序（Java實現）","date":"2018-07-13T06:49:07.000Z","updated":"2018-07-13T06:57:55.634Z","comments":true,"path":"2018/07/13/二分歸并排序（Java實現）/","link":"","permalink":"http://Altharsbuzhihuo.com/2018/07/13/二分歸并排序（Java實現）/","excerpt":"","text":"二分歸并排序 将数组从中切开分为一半，然后分区再继续划分子区间，直到分为只有两个元素比较或单个元素的无数个小区间。比较完各个分区两个元素大小之后，再将区间重新两两合并，合并过程中保持顺序由大到小排列。 时间复杂度：O(log₂n)空间复杂度：O(1) 123456789101112131415161718192021222324252627282930313233343536public void mergeSort(int[] arrays) &#123; int low,mid,high,base; for(int i=1;i&lt;arrays.length;i++) &#123; low=0; high=i-1; base=arrays[i]; while(low&lt;=high) &#123; mid=(low+high)/2; if(arrays[mid]&gt;base) &#123; low=mid+1; &#125; else if(arrays[mid]&lt;base) &#123; high=mid-1; &#125; &#125; for(int j=i-1;j&gt;=high+1;j--) &#123; arrays[j+1]=arrays[j]; &#125; arrays[high+1]=base; &#125; //依次打印排序后得到的结果 System.out.print(\"二分归并排序结果如下：\"); for(int i=0;i&lt;arrays.length;i++) &#123; System.out.print(arrays[i]+\" \"); &#125; System.out.print(\"\\n\"); &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/tags/数据结构/"},{"name":"二分歸并排序","slug":"二分歸并排序","permalink":"http://Altharsbuzhihuo.com/tags/二分歸并排序/"},{"name":"Java","slug":"Java","permalink":"http://Altharsbuzhihuo.com/tags/Java/"}]},{"title":"堆排序（Java实现）","slug":"堆排序（Java实现）","date":"2018-06-15T00:46:37.000Z","updated":"2018-07-13T06:42:34.492Z","comments":true,"path":"2018/06/15/堆排序（Java实现）/","link":"","permalink":"http://Altharsbuzhihuo.com/2018/06/15/堆排序（Java实现）/","excerpt":"","text":"堆排序 时间复杂度：(nlogn)空间复杂度：空间复杂度：O(1) 來不及解釋了，看代碼： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 重建堆（这里为最大堆） * 将数组处理为完全二叉树，使父结点&gt;左孩子&gt;右孩子 * 自下而上调整二叉树结点位置，根节点为数组最大值 * @param arrays 被排序数组 * @param n 数组长度 * @param h 非叶结点下标i */ public void CreateHeap(int[] arrays,int n,int h) &#123; //将非叶结点下标赋给i，定义叶子结点j int i=h; int j=2*i+1; //设置标志位flag为false boolean flag=false; int temp=arrays[i]; //查找左右孩子最大结点并交换到父结点 while(j&lt;n&amp;&amp;!flag)&#123; //如果左孩子小于右孩子就j++指向右孩子 if(j&lt;n-1&amp;&amp;arrays[j]&lt;arrays[j+1])j++; //如果父结点大于右孩子，则flag=true，本次循环结束 if(temp&gt;arrays[j]) &#123; flag=true; &#125; //否则将右孩子放入父结点 else &#123; arrays[i]=arrays[j]; i=j; j=2*i+1; &#125; &#125; //给子结点放入原父结点的值 arrays[i]=temp; &#125; /** * 堆排序 * @param arrays */ public void HeapSort(int[] arrays) &#123; //n为数组下标最后一位 int n=arrays.length-1; int temp=0; initHeap(arrays); //从小到大循环依次从堆中取出结点 for(int i=n;i&gt;0;i--) &#123; temp=arrays[0]; arrays[0]=arrays[i]; arrays[i]=temp; CreateHeap(arrays,i,0); &#125; //依次打印排序后得到的结果 System.out.print(\"堆排序结果如下：\"); for(int i=0;i&lt;=n;i++) &#123; System.out.print(arrays[i]+\" \"); &#125; System.out.print(\"\\n\"); &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/tags/数据结构/"},{"name":"Java","slug":"Java","permalink":"http://Altharsbuzhihuo.com/tags/Java/"},{"name":"堆排序","slug":"堆排序","permalink":"http://Altharsbuzhihuo.com/tags/堆排序/"}]},{"title":"快速排序（Java实现）","slug":"快速排序（Java实现）","date":"2018-06-06T11:40:35.000Z","updated":"2018-06-06T13:45:22.904Z","comments":true,"path":"2018/06/06/快速排序（Java实现）/","link":"","permalink":"http://Altharsbuzhihuo.com/2018/06/06/快速排序（Java实现）/","excerpt":"","text":"快速排序1.选择一个基准数x为arrays[0]，先从最右往左开始查找比x小的第一个数，找到后与arrays[i]交换位置。2.再从左往右开始查找比x大的第一个数，找到后再与arrays[j]交换位置。3.然后再重复1，2步骤，直到将数组中的数以x为基准分好区，此时i=j，将基准数x归位到arrays[i],左边的数都比x小，右边的数都比x大。4.以x为界形成两个子区间，然后分别进行递归，也就是重复以上步骤就排好了。 时间复杂度：平均为O(nlogn),最好为O(nlogn)，最坏为O(n2)空间复杂度：O(log₂n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 快速排序 * @param arrays 被排序数组 * @param l 区间最左边的下标 * @param r 区间最右边的下标 */ public void quickSort(int[] arrays,int l,int r) &#123; if(l&gt;r) &#123; return; &#125; //给i赋值为区间最左下标，给j赋值为区间最右下标 int i=l,j=r,x=arrays[i]; //以基准数x为标准，对数组的数进行分区，直到i==j，循环结束 while(i&lt;j) &#123; //从右往左循环查找比基准数小的数arrays[j]，并填入arrays[i]中 while(arrays[j]&gt;=x&amp;&amp;i&lt;j)j--; if(i&lt;j) &#123; arrays[i++]=arrays[j]; &#125; //从左往右循环查找比基准数大的数arrays[i]，并填入arrays[j]中 while(arrays[i]&lt;=x&amp;&amp;i&lt;j)i++; if(i&lt;j) &#123; arrays[j--]=arrays[i]; &#125; &#125; //此时i==j,将基准数x归位，使x左边的数都比x小，x右边的数都比x大 arrays[i]=x; //进行递归，将左右分区继续排序 if(l&lt;i)quickSort(arrays,l,i-1); if(r&gt;i)quickSort(arrays,i+1,r); &#125; /** * 给quicSort传递参数，最左下标为0，最右下标为数组长度减1 * @param a 被排序数组 */ public void QuickSort(int[] a) &#123; quickSort(a,0,a.length-1); //依次打印排序后得到的结果 System.out.print(\"快速排序结果如下：\"); for(int i=0;i&lt;a.length;i++) &#123; System.out.print(a[i]+\" \"); &#125; System.out.print(\"\\n\"); &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/tags/数据结构/"},{"name":"Java","slug":"Java","permalink":"http://Altharsbuzhihuo.com/tags/Java/"},{"name":"快速排序","slug":"快速排序","permalink":"http://Altharsbuzhihuo.com/tags/快速排序/"}]},{"title":"简单排序之冒泡排序、选择排序、插入排序（Java实现）","slug":"简单排序之冒泡排序、选择排序、插入排序（Java实现）","date":"2018-06-01T12:28:23.000Z","updated":"2018-06-06T13:02:02.975Z","comments":true,"path":"2018/06/01/简单排序之冒泡排序、选择排序、插入排序（Java实现）/","link":"","permalink":"http://Altharsbuzhihuo.com/2018/06/01/简单排序之冒泡排序、选择排序、插入排序（Java实现）/","excerpt":"","text":"今天写了一下数据结构里三种比较基础简单的排序算法。 1.冒泡排序升序的话就是，两两依次比较，然后把大的数往后沉下去，第一次排序结束，最后一个最大的数优先排好，然后进行第二次比较，如果数组长度为n，那么一共要进行n次比较，每一次进行n-i-1趟比较。 代码如下： 123456789101112131415161718192021222324public void bubbleSort(int[] arrays) &#123; int n=arrays.length; int temp=0; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n-i-1;j++) &#123; if(arrays[j]&gt;arrays[j+1]) &#123; temp=arrays[j+1]; arrays[j+1]=arrays[j]; arrays[j]=temp; &#125; &#125; &#125; //依次打印排序后得到的结果 System.out.print(\"冒泡排序结果如下：\"); for(int i=0;i&lt;n;i++) &#123; System.out.print(arrays[i]+\" \"); &#125; System.out.print(\"\\n\"); &#125; 时间复杂度:O(n²)空间复杂度:O(1) 2.选择排序同样也是升序，就是从数组下标0开始，依次比较，第一次比较出最小的数，和arrays[0]交换位置，然后依次类推，找出剩余最小的数，交换位置，如果数组长度为n，那么一共要进行n次比较，每一次比较n-i趟。 代码如下： 123456789101112131415161718192021222324252627public void selectSort(int[] arrays) &#123; int n=arrays.length; int temp=0; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n-i;j++) &#123; if(arrays[i]&gt;arrays[i+j]) &#123; temp=arrays[i]; arrays[i]=arrays[i+j]; arrays[i+j]=temp; &#125; &#125; &#125; //依次打印排序后得到的结果 System.out.print(\"选择排序结果如下：\"); for(int i=0;i&lt;n;i++) &#123; System.out.print(arrays[i]+\" \"); &#125; System.out.print(\"\\n\"); &#125; 时间复杂度:O(n²)空间复杂度:O(1) 3.插入排序升序，假定一个数组从arrays[0]开始，然后往里面依次插入数，保证每次插入的数顺序都已经排好。每当要插入arrays[j]时，从已排好序的数组的下标最后一位开始扫描，如果arrays[j]之前还有比它大的数就交换位置。如果数组长度为n，一共要比较n次，一共比较0+1+2+…+n-1次。 代码如下： 12345678910111213141516171819202122232425262728 public void insertSort(int[] arrays) &#123; int n=arrays.length; int temp=0; for(int i=0;i&lt;n;i++) &#123; for(int j=i;j&gt;0;j--) &#123; if(arrays[j-1]&gt;arrays[j]) &#123; temp=arrays[j-1]; arrays[j-1]=arrays[j]; arrays[j]=temp; &#125; &#125; &#125; //依次打印排序后得到的结果 System.out.print(\"插入排序结果如下：\"); for(int i=0;i&lt;n;i++) &#123; System.out.print(arrays[i]+\" \"); &#125; System.out.print(\"\\n\");&#125; 时间复杂度:O(n²)空间复杂度:O(1)","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/tags/数据结构/"},{"name":"Java","slug":"Java","permalink":"http://Altharsbuzhihuo.com/tags/Java/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"http://Altharsbuzhihuo.com/tags/冒泡排序/"},{"name":"选择排序","slug":"选择排序","permalink":"http://Altharsbuzhihuo.com/tags/选择排序/"},{"name":"插入排序","slug":"插入排序","permalink":"http://Altharsbuzhihuo.com/tags/插入排序/"}]},{"title":"字符串模式匹配算法（Java实现）","slug":"字符串模式匹配算法（Java实现）","date":"2018-05-31T06:58:45.000Z","updated":"2018-06-06T13:03:29.248Z","comments":true,"path":"2018/05/31/字符串模式匹配算法（Java实现）/","link":"","permalink":"http://Altharsbuzhihuo.com/2018/05/31/字符串模式匹配算法（Java实现）/","excerpt":"","text":"1.BF算法暴风(Brute Force)算法，又叫朴素算法,是一种比较好理解的简单字符串匹配算法。它是一种带回溯的模式匹配算法，将目标串依次逐字与模式串比较，再将得到的匹配结果输出。 代码如下：1234567891011121314151617181920212223242526public void searchAll(String str1,String str2)&#123; int i=0,j=0; int len1=str1.length(); int len2=str2.length(); //外层循环遍历目标字符串 for(i=0;i&lt;len1;i++)&#123; //内层循环遍历模式串 for(j=0;j&lt;len2;j++)&#123; //逐字比较是否一致，不一致则break结束内层循环 if(str1.charAt(i+j)!=str2.charAt(j)) &#123; break; &#125; //打印得到的匹配结果 else if(j==len-1) &#123; System.out.println(\"子串出现的位置为：\"+i); &#125; &#125; &#125; &#125; 时间复杂度： m=str1.length();n=str2.length(); 最好的情况：O(m)最坏的情况：O(n(n-m+1)m) 2.KMP算法有点复杂，还没写，以后再写","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/tags/数据结构/"},{"name":"Java","slug":"Java","permalink":"http://Altharsbuzhihuo.com/tags/Java/"},{"name":"模式匹配","slug":"模式匹配","permalink":"http://Altharsbuzhihuo.com/tags/模式匹配/"},{"name":"BF算法","slug":"BF算法","permalink":"http://Altharsbuzhihuo.com/tags/BF算法/"},{"name":"KMP算法","slug":"KMP算法","permalink":"http://Altharsbuzhihuo.com/tags/KMP算法/"}]}]}