{"meta":{"title":"Eat your own dogfood","subtitle":"皇家认证特级搜救犬","description":"Altharsbuzhihuo's blog","author":"Altharsbuzhihuo","url":"http://Altharsbuzhihuo.com"},"pages":[{"title":"关于我","date":"2018-05-26T08:09:37.000Z","updated":"2018-07-13T09:18:14.481Z","comments":true,"path":"page/关于我.html","permalink":"http://Altharsbuzhihuo.com/page/关于我.html","excerpt":"","text":"关于我皇家认证特级搜救犬混吃等死狗欢迎光临本小破站。 只要你主动，我们就会有故事。 我的联系方式：wechat：berlin1953v Email：tianranv@foxmail.com"},{"title":"categories","date":"2018-05-26T07:05:54.000Z","updated":"2018-05-26T07:06:43.366Z","comments":true,"path":"categories/index.html","permalink":"http://Altharsbuzhihuo.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-26T07:02:08.000Z","updated":"2018-05-26T07:03:50.652Z","comments":true,"path":"tags/index.html","permalink":"http://Altharsbuzhihuo.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Servlet","slug":"Servlet","date":"2018-07-19T01:56:44.000Z","updated":"2018-07-19T02:08:53.833Z","comments":true,"path":"2018/07/19/Servlet/","link":"","permalink":"http://Altharsbuzhihuo.com/2018/07/19/Servlet/","excerpt":"","text":"什么是Servlet？Servlet是一个Java程序，在服务器上运行以处理客户端请求并做出响应的程序。Servlet主要用于处 理客户端传来的HTTP请求，并返回一个响应，它能够处理的请求有 doGet()和doPost()等方法。Servlet由Servlet容器提供，所谓的Servlet容器是指提供了Servlet 功能的 服务器（本书中指Tomcat），Servlet容器将Servlet动态的加载到服务器 上。与HTTP 协议相关的Servlet使用HTTP请求和HTTP响应与客户端进行交互。因此，Servlet容器支持所有HTTP协议的请求和响应。 servlet的创建方式（三种）1.继承HttpServlet类实现一个自定义servlet[有http特性]2.通过实现Servlet接口实现一个自定义servlet[什么特性都没有，所有实现要自己写]3.继承GenericServlet抽象类实现一个自定义servlet[通过继承该抽象类实现类似于https特性的请求和响应] Servlet的配置方式（两种）1.基于XML的配置，在web.xml中通过servlet节点配置 &lt;servlet&gt; &lt;servlet-name&gt;secondServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;cx.servlet.SecondServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;-1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;secondServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/hstt.php&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 2.基于注解的配置（servlet3.0版本以上） @WebServlet(name = &quot;SimpleServlet&quot;,urlPatterns = {&quot;/simple.jsp&quot;}) servlet容器：运行servlet、JSP、Filter等软件环境1.可以来创建servlet，并调用servlet的相关生命周期方法。2.JSP，Filter，Listener，Tag… servlet生命周期方法1.构造器：只有第一次请求servlet时，创建servlet的实例，调用构造器（只被调用一次）。这说明servlet是单例的。2.init方法：只被调用一次，在创建好实例后立即被调用，用于初始化当前servlet。3.service：处理具体的请求返回响应，在具体子类中转交给了doGet方法或doPost方法。4.destory：只被调用一次，在当前servlet所在的web应用被卸载前调用，用于释放当前servlet所占用资源。 load-on-startup参数1.配置在web.xml的servlet节点中或者注解配置。servlet节点 &lt;servlet&gt; &lt;servlet-name&gt;secondServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;cx.servlet.SecondServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;-1&lt;/load-on-startup&gt; &lt;/servlet&gt; 注解 @WebServlet( loadOnStartup = 1, urlPatterns = {&quot;/si.do&quot;,&quot;/servletTest.jsp&quot;}) 一个servlet类可用配置多个url映射，而且注解的配置和xml配置可用配置到同一个servlet类上。 2.load-on-startup：可以指定servlet被创建的时机。若为负数，则在第一次请求时被创建。若为0或负数，则在当前web应用被servlet容器加载时创建实例，且数据越小越早被创建。 关于servlet-mapping一个servlet可以对应多个servlet-mapping 虚拟路径：“.扩展名”，”/“ 合法 注意：/*.action不合法 ServletConfig封装了servlet的配置信息，并且可以获取servletContext对象1.配置servlet初始化参数 &lt;init-param&gt; &lt;param-name&gt;user&lt;/param-name&gt; &lt;param-value&gt;root&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;123&lt;/param-value&gt; &lt;/init-param&gt; 该节点必须在load-on-startup节点之前 2.获取初始化参数：配置初始化参数的两种方式：web.xml &lt;context-param&gt; &lt;param-name&gt;driver&lt;/param-name&gt; &lt;param-value&gt;com.mysql.jdbc.Driver&lt;/param-value&gt; &lt;/context-param&gt; 注解 @WebServlet{ urlPatterns={&quot;/hello.do&quot;}, initParams={@WebInitParam(name = &quot;code&quot;,value = &quot;UTF-8&quot;) } } getInitParameter(String name):获取指定参数名的初始化参数getInitParameterNames():获取参数名组成的Enumeration对象 ServletContext通过ServletContext接口读取 上下文参数（用于多个servlet间共享配置和数据） 1.可以由ServletConfig获取servletContext对象 ServletContext servletContext=servletConfig.getServletContext(); 2.ServletContext是当前web应用的一个大管家，可以获取到当前web应用的各方面信息。 获取当前web应用的初始化参数 设置上下文参数（context-param可以为所有Servlet所获取，而Servlet的初始化参数init-param只给那个Servlet可以获取） &lt;context-param&gt; &lt;param-name&gt;driver&lt;/param-name&gt; &lt;param-value&gt;com.mysql.jdbc.Driver&lt;/param-value&gt; &lt;/context-param&gt; ##获取当前web应用的某一个文件的路径得到的返回结果为在服务器上的绝对路径，而不是部署前的路径 getRealPath(String path) ServletContext servletContext=this.getServletContext(); String contextInit= servletContext.getInitParameter(&quot;coding&quot;); System.out.println(&quot;读取到上下文的配置参数值：&quot;+contextInit); servletContext.setAttribute(&quot;gkey&quot;,&quot;全局共享的数据&quot;); System.out.println(&quot;上下文的属性数据：&quot;+servletContext.getAttribute(&quot;gkey&quot;)); String realPath=servletContext.getRealPath(&quot;WEB-INF/classes/cx.properties&quot;); FileInputStream in=new FileInputStream(realPath); Properties ppt=new Properties(); ppt.load(in); System.out.println(ppt.getProperty(&quot;Company&quot;)); System.out.println(ppt.getProperty(&quot;Address&quot;)); ##获取当前web应用的名称 getContextPath() ##获取当前web应用的某一个文件对应的输入流 getResourceAsStream(String path) path–&gt; ‘/‘相当于当前web的根目录 Get请求和Post请求1.Get请求传参在url，Get方式传送的数据量一般限制在1KB以下。2.Post请求方式主要用于向web服务器端程序提交form表单中的数据，form中metho置为post。Post方式将各个表单字段及其数据作为HTTP消息实体内容发送给web服务器，传送数据量比get大得多。 如何在Servlet中获得请求信息？1.servlet的service()方法,每次请求都会调用service方法。 ServletRequest：封装了请求信息，可以从中获取任何的请求信息。ServletResponse：封装了响应信息，如果想给用户什么响应，具体可以使用该接口方法实现。这两个接口的实现类都是服务器予以实现的。 获得请求参数 String user=request.getParameter(“user”) 获得当前servlet的刷新次数12345678910111213141516171819202122232425public class OnlineNumberServlet extends HttpServlet &#123; public void init()throws ServletException&#123; //设置初始化参数 ServletContext servletContext=this.getServletContext(); servletContext.setAttribute(&quot;num&quot;,1); System.out.println(&quot;当前servlet的访问次数：&quot;+1); super.init(); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //每刷新一次就将访问数量+1 ServletContext servletContext=this.getServletContext(); Integer val=(Integer) servletContext.getAttribute(&quot;num&quot;); val++; servletContext.setAttribute(&quot;num&quot;,val); System.out.println(&quot;当前本servlet访问次数：&quot;+val+&quot;&quot;); response.setCharacterEncoding(&quot;GBK&quot;); response.getWriter().println(&quot;当前本servlet访问次数：&quot;+val+&quot;&quot;); &#125;&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://Altharsbuzhihuo.com/categories/笔记/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://Altharsbuzhihuo.com/tags/笔记/"},{"name":"javaweb","slug":"javaweb","permalink":"http://Altharsbuzhihuo.com/tags/javaweb/"},{"name":"Servlet","slug":"Servlet","permalink":"http://Altharsbuzhihuo.com/tags/Servlet/"}]},{"title":"搭建个人博客，Hexo+Github","slug":"搭建个人博客，Hexo+Github","date":"2018-07-16T01:43:57.000Z","updated":"2018-07-16T16:53:27.996Z","comments":true,"path":"2018/07/16/搭建个人博客，Hexo+Github/","link":"","permalink":"http://Altharsbuzhihuo.com/2018/07/16/搭建个人博客，Hexo+Github/","excerpt":"","text":"准备工作为什么要用Hexo+Github自建博客？自己建的博客有完全的自主权，你可以自己做各种程序上的修改，完整的备份等等～微软这么大的博客系统都可以一夜之间关掉，你还敢用吗？当然是因为Hexo简单，开源，不要钱，可以为所欲为啊。 什么是Hexo？Hexo官方文档Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 环境安装1.配置Github首先注册/登录Github，看不懂英语，用谷歌浏览器可以翻译网页。 github网址记住自己的username和注册邮箱 选择Create a new repository新建一个仓库 Repository name（填自己的名字） name.github.io(name与你的注册用户名一致,这个就是你博客的域名了) eg:我的域名是github.com/Altharsbuzhihuo，就填入Altharsbuzhihuo.github.io。成功后出现下面的画面: 2.安装 Node.js Node.js安装地址 3.安装 Git Git安装地址Git教程 4.安装完成后,鼠标右键选择–&gt;Git Bash here 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。 5.安装Hexo使用cmd命令窗口输入如下命令： npm install -g hexo-cli 等待下载，成功后输入 npm -v 会显示版本 设置在电脑F盘或者随意什么目录下新建文件test，进入test按住shift点击鼠标右键打开命令行窗口，输入：1hexo init blog 等待下载成功提示：1INFO Start blogging with Hexo! 因为初始化hexo之后source目录下自带一篇hello world文章, 所以直接执行下方命令:1234567#发布草稿，生成预览$ hexo g#启动本地服务器$ hexo s#提示信息INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 访问 http://localhost:4000/， 可以看到网站的初步样子。 重新打开CMD，输入： 1ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot; 一直Enter，得到信息：1Your public key has been saved in /c/Users/user/.ssh/id_rsa.pub. 找到该文件，打开（sublime text），Ctrl + a复制里面的所有内容，然后进入Sign in to GitHub：https://github.com/settings/ssh New SSH key ——Title：blog —— Key：输入刚才复制的—— Add SSH key 设置博客在blog目录下，打开_config.yml文件，修改参数信息。 每个参数后使用一个英文空格 发表文章123# 测试文章$ hexo new &quot;test&quot;INFO Created: E:\\Git\\workspace\\test\\blog\\source\\_posts\\test.md 根据文件路径找到该文章，使用markdown编辑语法。12345---title: testdate: 2018-07-17 00:20:54---这是一篇测试文章。 保存，然后执行如下步骤：12345678910111213141516F:\\test\\blog$ hexo cleanINFO Deleted database.INFO Deleted public folder.F:\\test\\blog$ hexo gINFO Start processingINFO Files loaded in 1.48 s#省略INFO 29 files generated in 4.27 sF:\\test\\blog$ hexo sINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 这个时候，打开http://localhost:4000/ ，发现刚才的文章已经成功了 最后一步，部署发布，执行：12F:\\test\\blog$ hexo d 打开博客链接 https://Altharsbuzhihuo.github.io 就能看到发布了。 相关链接：Hexo的next主题个性化教程","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"http://Altharsbuzhihuo.com/categories/搭建博客/"}],"tags":[{"name":"搭建博客","slug":"搭建博客","permalink":"http://Altharsbuzhihuo.com/tags/搭建博客/"},{"name":"Hexo","slug":"Hexo","permalink":"http://Altharsbuzhihuo.com/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"http://Altharsbuzhihuo.com/tags/Github/"}]},{"title":"二分歸并排序（Java實現）","slug":"二分歸并排序（Java實現）","date":"2018-07-13T06:49:07.000Z","updated":"2018-07-13T06:57:55.634Z","comments":true,"path":"2018/07/13/二分歸并排序（Java實現）/","link":"","permalink":"http://Altharsbuzhihuo.com/2018/07/13/二分歸并排序（Java實現）/","excerpt":"","text":"二分歸并排序 将数组从中切开分为一半，然后分区再继续划分子区间，直到分为只有两个元素比较或单个元素的无数个小区间。比较完各个分区两个元素大小之后，再将区间重新两两合并，合并过程中保持顺序由大到小排列。 时间复杂度：O(log₂n)空间复杂度：O(1) 123456789101112131415161718192021222324252627282930313233343536public void mergeSort(int[] arrays) &#123; int low,mid,high,base; for(int i=1;i&lt;arrays.length;i++) &#123; low=0; high=i-1; base=arrays[i]; while(low&lt;=high) &#123; mid=(low+high)/2; if(arrays[mid]&gt;base) &#123; low=mid+1; &#125; else if(arrays[mid]&lt;base) &#123; high=mid-1; &#125; &#125; for(int j=i-1;j&gt;=high+1;j--) &#123; arrays[j+1]=arrays[j]; &#125; arrays[high+1]=base; &#125; //依次打印排序后得到的结果 System.out.print(\"二分归并排序结果如下：\"); for(int i=0;i&lt;arrays.length;i++) &#123; System.out.print(arrays[i]+\" \"); &#125; System.out.print(\"\\n\"); &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/tags/数据结构/"},{"name":"二分歸并排序","slug":"二分歸并排序","permalink":"http://Altharsbuzhihuo.com/tags/二分歸并排序/"},{"name":"Java","slug":"Java","permalink":"http://Altharsbuzhihuo.com/tags/Java/"}]},{"title":"堆排序（Java实现）","slug":"堆排序（Java实现）","date":"2018-06-15T00:46:37.000Z","updated":"2018-07-13T06:42:34.492Z","comments":true,"path":"2018/06/15/堆排序（Java实现）/","link":"","permalink":"http://Altharsbuzhihuo.com/2018/06/15/堆排序（Java实现）/","excerpt":"","text":"堆排序 时间复杂度：(nlogn)空间复杂度：空间复杂度：O(1) 來不及解釋了，看代碼： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 重建堆（这里为最大堆） * 将数组处理为完全二叉树，使父结点&gt;左孩子&gt;右孩子 * 自下而上调整二叉树结点位置，根节点为数组最大值 * @param arrays 被排序数组 * @param n 数组长度 * @param h 非叶结点下标i */ public void CreateHeap(int[] arrays,int n,int h) &#123; //将非叶结点下标赋给i，定义叶子结点j int i=h; int j=2*i+1; //设置标志位flag为false boolean flag=false; int temp=arrays[i]; //查找左右孩子最大结点并交换到父结点 while(j&lt;n&amp;&amp;!flag)&#123; //如果左孩子小于右孩子就j++指向右孩子 if(j&lt;n-1&amp;&amp;arrays[j]&lt;arrays[j+1])j++; //如果父结点大于右孩子，则flag=true，本次循环结束 if(temp&gt;arrays[j]) &#123; flag=true; &#125; //否则将右孩子放入父结点 else &#123; arrays[i]=arrays[j]; i=j; j=2*i+1; &#125; &#125; //给子结点放入原父结点的值 arrays[i]=temp; &#125; /** * 堆排序 * @param arrays */ public void HeapSort(int[] arrays) &#123; //n为数组下标最后一位 int n=arrays.length-1; int temp=0; initHeap(arrays); //从小到大循环依次从堆中取出结点 for(int i=n;i&gt;0;i--) &#123; temp=arrays[0]; arrays[0]=arrays[i]; arrays[i]=temp; CreateHeap(arrays,i,0); &#125; //依次打印排序后得到的结果 System.out.print(\"堆排序结果如下：\"); for(int i=0;i&lt;=n;i++) &#123; System.out.print(arrays[i]+\" \"); &#125; System.out.print(\"\\n\"); &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/tags/数据结构/"},{"name":"Java","slug":"Java","permalink":"http://Altharsbuzhihuo.com/tags/Java/"},{"name":"堆排序","slug":"堆排序","permalink":"http://Altharsbuzhihuo.com/tags/堆排序/"}]},{"title":"快速排序（Java实现）","slug":"快速排序（Java实现）","date":"2018-06-06T11:40:35.000Z","updated":"2018-06-06T13:45:22.904Z","comments":true,"path":"2018/06/06/快速排序（Java实现）/","link":"","permalink":"http://Altharsbuzhihuo.com/2018/06/06/快速排序（Java实现）/","excerpt":"","text":"快速排序1.选择一个基准数x为arrays[0]，先从最右往左开始查找比x小的第一个数，找到后与arrays[i]交换位置。2.再从左往右开始查找比x大的第一个数，找到后再与arrays[j]交换位置。3.然后再重复1，2步骤，直到将数组中的数以x为基准分好区，此时i=j，将基准数x归位到arrays[i],左边的数都比x小，右边的数都比x大。4.以x为界形成两个子区间，然后分别进行递归，也就是重复以上步骤就排好了。 时间复杂度：平均为O(nlogn),最好为O(nlogn)，最坏为O(n2)空间复杂度：O(log₂n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 快速排序 * @param arrays 被排序数组 * @param l 区间最左边的下标 * @param r 区间最右边的下标 */ public void quickSort(int[] arrays,int l,int r) &#123; if(l&gt;r) &#123; return; &#125; //给i赋值为区间最左下标，给j赋值为区间最右下标 int i=l,j=r,x=arrays[i]; //以基准数x为标准，对数组的数进行分区，直到i==j，循环结束 while(i&lt;j) &#123; //从右往左循环查找比基准数小的数arrays[j]，并填入arrays[i]中 while(arrays[j]&gt;=x&amp;&amp;i&lt;j)j--; if(i&lt;j) &#123; arrays[i++]=arrays[j]; &#125; //从左往右循环查找比基准数大的数arrays[i]，并填入arrays[j]中 while(arrays[i]&lt;=x&amp;&amp;i&lt;j)i++; if(i&lt;j) &#123; arrays[j--]=arrays[i]; &#125; &#125; //此时i==j,将基准数x归位，使x左边的数都比x小，x右边的数都比x大 arrays[i]=x; //进行递归，将左右分区继续排序 if(l&lt;i)quickSort(arrays,l,i-1); if(r&gt;i)quickSort(arrays,i+1,r); &#125; /** * 给quicSort传递参数，最左下标为0，最右下标为数组长度减1 * @param a 被排序数组 */ public void QuickSort(int[] a) &#123; quickSort(a,0,a.length-1); //依次打印排序后得到的结果 System.out.print(\"快速排序结果如下：\"); for(int i=0;i&lt;a.length;i++) &#123; System.out.print(a[i]+\" \"); &#125; System.out.print(\"\\n\"); &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/tags/数据结构/"},{"name":"Java","slug":"Java","permalink":"http://Altharsbuzhihuo.com/tags/Java/"},{"name":"快速排序","slug":"快速排序","permalink":"http://Altharsbuzhihuo.com/tags/快速排序/"}]},{"title":"简单排序之冒泡排序、选择排序、插入排序（Java实现）","slug":"简单排序之冒泡排序、选择排序、插入排序（Java实现）","date":"2018-06-01T12:28:23.000Z","updated":"2018-06-06T13:02:02.975Z","comments":true,"path":"2018/06/01/简单排序之冒泡排序、选择排序、插入排序（Java实现）/","link":"","permalink":"http://Altharsbuzhihuo.com/2018/06/01/简单排序之冒泡排序、选择排序、插入排序（Java实现）/","excerpt":"","text":"今天写了一下数据结构里三种比较基础简单的排序算法。 1.冒泡排序升序的话就是，两两依次比较，然后把大的数往后沉下去，第一次排序结束，最后一个最大的数优先排好，然后进行第二次比较，如果数组长度为n，那么一共要进行n次比较，每一次进行n-i-1趟比较。 代码如下： 123456789101112131415161718192021222324public void bubbleSort(int[] arrays) &#123; int n=arrays.length; int temp=0; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n-i-1;j++) &#123; if(arrays[j]&gt;arrays[j+1]) &#123; temp=arrays[j+1]; arrays[j+1]=arrays[j]; arrays[j]=temp; &#125; &#125; &#125; //依次打印排序后得到的结果 System.out.print(\"冒泡排序结果如下：\"); for(int i=0;i&lt;n;i++) &#123; System.out.print(arrays[i]+\" \"); &#125; System.out.print(\"\\n\"); &#125; 时间复杂度:O(n²)空间复杂度:O(1) 2.选择排序同样也是升序，就是从数组下标0开始，依次比较，第一次比较出最小的数，和arrays[0]交换位置，然后依次类推，找出剩余最小的数，交换位置，如果数组长度为n，那么一共要进行n次比较，每一次比较n-i趟。 代码如下： 123456789101112131415161718192021222324252627public void selectSort(int[] arrays) &#123; int n=arrays.length; int temp=0; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n-i;j++) &#123; if(arrays[i]&gt;arrays[i+j]) &#123; temp=arrays[i]; arrays[i]=arrays[i+j]; arrays[i+j]=temp; &#125; &#125; &#125; //依次打印排序后得到的结果 System.out.print(\"选择排序结果如下：\"); for(int i=0;i&lt;n;i++) &#123; System.out.print(arrays[i]+\" \"); &#125; System.out.print(\"\\n\"); &#125; 时间复杂度:O(n²)空间复杂度:O(1) 3.插入排序升序，假定一个数组从arrays[0]开始，然后往里面依次插入数，保证每次插入的数顺序都已经排好。每当要插入arrays[j]时，从已排好序的数组的下标最后一位开始扫描，如果arrays[j]之前还有比它大的数就交换位置。如果数组长度为n，一共要比较n次，一共比较0+1+2+…+n-1次。 代码如下： 12345678910111213141516171819202122232425262728 public void insertSort(int[] arrays) &#123; int n=arrays.length; int temp=0; for(int i=0;i&lt;n;i++) &#123; for(int j=i;j&gt;0;j--) &#123; if(arrays[j-1]&gt;arrays[j]) &#123; temp=arrays[j-1]; arrays[j-1]=arrays[j]; arrays[j]=temp; &#125; &#125; &#125; //依次打印排序后得到的结果 System.out.print(\"插入排序结果如下：\"); for(int i=0;i&lt;n;i++) &#123; System.out.print(arrays[i]+\" \"); &#125; System.out.print(\"\\n\");&#125; 时间复杂度:O(n²)空间复杂度:O(1)","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/tags/数据结构/"},{"name":"Java","slug":"Java","permalink":"http://Altharsbuzhihuo.com/tags/Java/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"http://Altharsbuzhihuo.com/tags/冒泡排序/"},{"name":"选择排序","slug":"选择排序","permalink":"http://Altharsbuzhihuo.com/tags/选择排序/"},{"name":"插入排序","slug":"插入排序","permalink":"http://Altharsbuzhihuo.com/tags/插入排序/"}]},{"title":"字符串模式匹配算法（Java实现）","slug":"字符串模式匹配算法（Java实现）","date":"2018-05-31T06:58:45.000Z","updated":"2018-06-06T13:03:29.248Z","comments":true,"path":"2018/05/31/字符串模式匹配算法（Java实现）/","link":"","permalink":"http://Altharsbuzhihuo.com/2018/05/31/字符串模式匹配算法（Java实现）/","excerpt":"","text":"1.BF算法暴风(Brute Force)算法，又叫朴素算法,是一种比较好理解的简单字符串匹配算法。它是一种带回溯的模式匹配算法，将目标串依次逐字与模式串比较，再将得到的匹配结果输出。 代码如下：1234567891011121314151617181920212223242526public void searchAll(String str1,String str2)&#123; int i=0,j=0; int len1=str1.length(); int len2=str2.length(); //外层循环遍历目标字符串 for(i=0;i&lt;len1;i++)&#123; //内层循环遍历模式串 for(j=0;j&lt;len2;j++)&#123; //逐字比较是否一致，不一致则break结束内层循环 if(str1.charAt(i+j)!=str2.charAt(j)) &#123; break; &#125; //打印得到的匹配结果 else if(j==len-1) &#123; System.out.println(\"子串出现的位置为：\"+i); &#125; &#125; &#125; &#125; 时间复杂度： m=str1.length();n=str2.length(); 最好的情况：O(m)最坏的情况：O(n(n-m+1)m) 2.KMP算法有点复杂，还没写，以后再写","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Altharsbuzhihuo.com/tags/数据结构/"},{"name":"Java","slug":"Java","permalink":"http://Altharsbuzhihuo.com/tags/Java/"},{"name":"模式匹配","slug":"模式匹配","permalink":"http://Altharsbuzhihuo.com/tags/模式匹配/"},{"name":"BF算法","slug":"BF算法","permalink":"http://Altharsbuzhihuo.com/tags/BF算法/"},{"name":"KMP算法","slug":"KMP算法","permalink":"http://Altharsbuzhihuo.com/tags/KMP算法/"}]}]}