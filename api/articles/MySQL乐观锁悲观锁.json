{"title":"MySQL乐观锁悲观锁","slug":"MySQL乐观锁悲观锁","date":"2018-08-19T11:45:52.000Z","updated":"2018-08-19T11:51:47.459Z","comments":true,"excerpt":"","content":"<h1 id=\"MySQL乐观锁悲观锁\"><a href=\"#MySQL乐观锁悲观锁\" class=\"headerlink\" title=\"MySQL乐观锁悲观锁\"></a>MySQL乐观锁悲观锁</h1><h3 id=\"一、并发控制\"><a href=\"#一、并发控制\" class=\"headerlink\" title=\"一、并发控制\"></a>一、并发控制</h3><p>​       同一时刻可能会有多个用户更新同一张表的同一条记录。这就会产生冲突，这就是<a href=\"http://blog.csdn.net/qq_26545305/article/details/52577621\" target=\"_blank\" rel=\"noopener\">并发性问题</a>。数据库的并发操作通常会导致、丢失更新、读脏数据、不可重复读等问题。</p>\n<h3 id=\"二、悲观锁和乐观锁\"><a href=\"#二、悲观锁和乐观锁\" class=\"headerlink\" title=\"二、悲观锁和乐观锁\"></a>二、悲观锁和乐观锁</h3><p>​       乐观锁顾名思义就是非常乐观啦，它认为所有的操作都不会产生并发冲突。与之相对应的就是悲观锁。它呢比较悲观，认为所有的操作都会产生并发冲突。</p>\n<p>​       其实呢，乐观锁和悲观锁在代码层（java）、缓存层（redis）、数据库层（mysql）都有自己的实现。今天呢，我们就谈一谈在数据库层的实现。</p>\n<p>​       乐观锁呢，其实并没有锁，只是这么一种叫法而已。大多是基于数据版本（Version）记录机制实现。悲观锁大多数情况下依赖数据库自身锁机制实现，以保证操作最大程度的独占性。加锁当然伴随着的就是资源的消耗了，比如获得获得锁，释放锁等。<strong>乐观锁加版本号，悲观锁关闭自动提交。</strong></p>\n<h3 id=\"三、乐观锁实现\"><a href=\"#三、乐观锁实现\" class=\"headerlink\" title=\"三、乐观锁实现\"></a>三、乐观锁实现</h3><p>​       一般是先给表加一个版本号（version）字段。当读取数据时，将version字段的值一同读出。每操作（更新）一次，将那条记录的version加1。当我们提交更新的时候，判断此刻的version值是否与刚刚查询出来的version值相等。如果相等，则说明这段期间，没有其他程序对其进行操作（更新）。则予以更新，将version字段的值加1；否则认为是过期数据，拒绝更新。</p>\n<p>​      ①数据表设计  task  有三个字段，分别是id、value、version</p>\n<p>​      ②每次更新task表中的value字段，为了防止发生冲突，需要这样操作。</p>\n<p>​      update task set value=newValue,version=versionValue+1  where id=1 and version=versionValue ;</p>\n<p>​      只有这条语句执行了，才表明本次更新value字段的值成功</p>\n<p>​       假如有两个节点A和B都要更新task表中的value字段，在同一时刻，A节点和B节点从task表中读到的version值为2，那么A节点和B节点在更新value字段值的时候，都执行update task set value=newValue，version=3 where id=1 and version=2；实际上只有1个节点执行该SQL语句成功，假设A节点执行成功，那么此刻task表的version字段的值是3，B节点在执行 update task set value=newValue，version=3 where id=1 and version=2 这条SQL语句是不执行的。这样就保证了更新task表时不发生冲突。</p>\n<h3 id=\"四、悲观锁实现\"><a href=\"#四、悲观锁实现\" class=\"headerlink\" title=\"四、悲观锁实现\"></a>四、悲观锁实现</h3><p>​       要使用悲观锁，需要关闭mysql数据库的自动提交属性，因为mysql默认使用autocommit模式，也就是说，当你执行一个更新操作后，mysql会立即将结果进行提交。</p>\n<p>​        使用命令设置mysql 为非autocommit模式：set autocommit =0；</p>\n<p>​       一般使用select … for update<strong>对所选择的数据进行加锁处理</strong>，例如，select status form t_goods where id in (‘1’,’2’)  for update;这条sql语句会锁定t_goods表中id为1和id为2的记录。</p>\n<p>​       使用场景举例：商品t_goods表有一个字段status，status为1代表商品未被下单，status为2代表商品已经被下单，那么我们队某个商品下单是必须确保该商品status为1.假设商品的id为1</p>\n<p>​       ①begin/begin work/start transaction；//开始事务</p>\n<p>​       ②select status from t_goods where id=1 <strong>for update</strong>；//查询出商品信息</p>\n<p>​       ③insert into t_orders(id,goods_id) value (null,1);//根据商品信息生成订单</p>\n<p>​       ④update t_goods set status=2;//修改商品status为2</p>\n<p>​       ⑤commit/commit work;//提交事务</p>\n","categories":[{"name":"数据库","path":"api/categories/数据库.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"},{"name":"数据库","path":"api/tags/数据库.json"}]}