{"title":"B-tree和B+tree","slug":"B-tree和B-tree","date":"2018-08-26T12:12:22.000Z","updated":"2018-08-26T12:26:52.937Z","comments":true,"excerpt":"","content":"<h3 id=\"B-tree\"><a href=\"#B-tree\" class=\"headerlink\" title=\"B-tree\"></a>B-tree</h3><p>B-tree( Balance tree )，也就是平衡树。 相对于二叉树而言，B-tree每个节点有多个分支，即多叉，所以又叫多路搜索树。这个数据结构一般用于数据库的索引，查找效率比较高。</p>\n<p>B-tree结构的数据首先包含一个二元组[key,data]，key为记录的键值，对应表中的主键值，data为除主键外的数据；每个非终端节点（即非根节点和叶子节点）包含指向子树根节点的指针Pi ( i=1，2，3…n )。</p>\n<p>m阶B-Tree满足以下条件：</p>\n<p>1、每个节点最多拥有m个子树</p>\n<p>2、根节点至少有2个子树</p>\n<p>3、分支节点至少拥有m/2颗子树（除根节点和叶子节点外都是分支节点）</p>\n<p>4、所有叶子节点都在同一层、每个节点最多可以有m-1个key，并且以升序排列</p>\n<p><img src=\"\\img\\20160202204827368.png\" alt=\"B-tree\"></p>\n<h3 id=\"B-tree-1\"><a href=\"#B-tree-1\" class=\"headerlink\" title=\"B+tree\"></a>B+tree</h3><p>与B-tree结构类似，B+tree是在B-tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就使用了B+tree算法处理索引结构。</p>\n<p>B-tree的每个节点不仅包含数据的key值，还有data值。而每个节点的存储空间有限，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储数据量很大时会导致B-tree的深度较大，影响查询效率。</p>\n<p>在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。 </p>\n<p>B+tree相对于B-tree的不同：</p>\n<ol>\n<li>非叶子节点只存储键值信息。</li>\n<li>所有叶子节点之间都有一个链指针。</li>\n<li>数据记录都存放在叶子节点中。</li>\n</ol>\n<p><img src=\"\\img\\20160202205105560.png\" alt=\"B+tree\"></p>\n<p>通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。 </p>\n<p>数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。上面的B+Tree在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。 </p>\n","categories":[{"name":"数据结构","path":"api/categories/数据结构.json"}],"tags":[{"name":"数据结构","path":"api/tags/数据结构.json"},{"name":"树","path":"api/tags/树.json"}]}