{"title":"Jsp","slug":"Jsp","date":"2018-07-29T12:46:20.000Z","updated":"2018-07-29T12:56:18.079Z","comments":true,"excerpt":"","content":"<h1 id=\"Jsp\"><a href=\"#Jsp\" class=\"headerlink\" title=\"Jsp\"></a>Jsp</h1><p>Jsp只是servlet的一个变种，为了方便书写html内容才出现。servlet是根本，所有jsp能做的，servlet全能做。</p>\n<h1 id=\"Jsp与Js的区别\"><a href=\"#Jsp与Js的区别\" class=\"headerlink\" title=\"Jsp与Js的区别\"></a>Jsp与Js的区别</h1><p>JS是在客户端执行的，需要浏览器支持Javascript。JSP是在服务器端执行的，需要服务器上部署支持Servlet的服务器程序。JS代码是能够直接从服务器上download得到，对外是可见的，jsp(和翻译后的servlet)代码是对外不可见的。<br><strong>JS与JavaScript相比：</strong>虽然JavaScript可以在客户端动态生成HTML，但是很难与服务器交互，因此不能提供复杂的服务，比如访问数据库和图像处理等等。JSP在HTML中用&lt;%%&gt;里面实现。JS在html中用<script></script>实现。</p>\n<h1 id=\"Jsp的生命周期\"><a href=\"#Jsp的生命周期\" class=\"headerlink\" title=\"Jsp的生命周期\"></a>Jsp的生命周期</h1><p>JSP生命周期就是从创建到销毁的整个过程，类似于servlet生命周期，区别在于JSP生命周期还包括将JSP文件编译成servlet。</p>\n<p>以下是JSP生命周期中所走过的几个阶段：</p>\n<ul>\n<li>编译阶段：<br>servlet容器编译servlet源文件，生成servlet类</li>\n<li>初始化阶段：<br>加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法</li>\n<li>执行阶段：<br>调用与JSP对应的servlet实例的服务方法</li>\n<li>执行阶段：<br>调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例</li>\n</ul>\n<h1 id=\"Jsp指令\"><a href=\"#Jsp指令\" class=\"headerlink\" title=\"Jsp指令\"></a>Jsp指令</h1><pre><code>#定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等\n&lt;%@page...%&gt;\n#包含其他文件\n&lt;%@include...%&gt;\n#引入标签库的定义，可以是自定义标签\n&lt;%@taglib...%&gt;\n</code></pre><h1 id=\"Jsp四个作用域-page-lt-request-lt-session-lt-application\"><a href=\"#Jsp四个作用域-page-lt-request-lt-session-lt-application\" class=\"headerlink\" title=\"Jsp四个作用域(page&lt; request &lt; session &lt; application)\"></a>Jsp四个作用域(page&lt; request &lt; session &lt; application)</h1><p>所谓作用域，规定的是变量的有效期限。</p>\n<h2 id=\"page\"><a href=\"#page\" class=\"headerlink\" title=\"page\"></a>page</h2><p>有效范围只在当前jsp页面。</p>\n<h2 id=\"request\"><a href=\"#request\" class=\"headerlink\" title=\"request\"></a>request</h2><p>有效范围是当前请求周期。</p>\n<h2 id=\"session\"><a href=\"#session\" class=\"headerlink\" title=\"session\"></a>session</h2><p>有效范围是当前会话。</p>\n<p>所谓当前会话，就是指从用户打开浏览器开始，到用户关闭浏览器这中间的过程。也就是说，只要用户不关闭浏览器，服务器就有办法知道这些请求是一个人发起的，整个过程被称为一个会话(session)，而放入会话里的所有变量，就可以在当前所有请求中使用。</p>\n<h2 id=\"application\"><a href=\"#application\" class=\"headerlink\" title=\"application\"></a>application</h2><p>有效范围是整个应用。</p>\n<p>整个应用是指从应用启动，到应用结束。一个服务器可能部署多个应用，当然你关闭了服务器，就会把上面所有的应用都关闭了。</p>\n<p>与上述三个不同的是，application里的变量可以被所有用户共用。如果用户甲的操作修改了application中的变量，用户乙访问时得到的是修改后的值。这在其他scope中都是不会发生的，page, request,session都是完全隔离的，无论如何修改都不会影响其他人的数据。</p>\n<h1 id=\"Jsp九个内置对象\"><a href=\"#Jsp九个内置对象\" class=\"headerlink\" title=\"Jsp九个内置对象\"></a>Jsp九个内置对象</h1><table>\n<thead>\n<tr>\n<th>内置对象</th>\n<th style=\"text-align:center\">类型</th>\n<th>作用域</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>request</td>\n<td style=\"text-align:center\">请求对象</td>\n<td>Request</td>\n<td>HttpServletRequest类的实例</td>\n</tr>\n<tr>\n<td>response</td>\n<td style=\"text-align:center\">响应对象</td>\n<td>Page</td>\n<td>HttpServletResponse类的实例</td>\n</tr>\n<tr>\n<td>pageContext</td>\n<td style=\"text-align:center\">页面上下文对象</td>\n<td>Page</td>\n<td>PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问</td>\n</tr>\n<tr>\n<td>session</td>\n<td style=\"text-align:center\">会话对象</td>\n<td>Session</td>\n<td>HttpSession类的实例</td>\n</tr>\n<tr>\n<td>application</td>\n<td style=\"text-align:center\">应用程序对象</td>\n<td>Application</td>\n<td>ServletContext类的实例，与应用上下文有关</td>\n</tr>\n<tr>\n<td>out</td>\n<td style=\"text-align:center\">输出对象</td>\n<td>Page</td>\n<td>PrintWriter类的实例，用于把结果输出至网页上</td>\n</tr>\n<tr>\n<td>config</td>\n<td style=\"text-align:center\">配置对象</td>\n<td>Page</td>\n<td>ServletConfig类的实例</td>\n</tr>\n<tr>\n<td>page</td>\n<td style=\"text-align:center\">页面对象</td>\n<td>Page</td>\n<td>类似于Java类中的this关键字</td>\n</tr>\n<tr>\n<td>exception</td>\n<td style=\"text-align:center\">例外对象</td>\n<td>Page</td>\n<td>Exception类的对象，代表发生错误的JSP页面中对应的异常对象</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"Jsp的七个动作指令\"><a href=\"#Jsp的七个动作指令\" class=\"headerlink\" title=\"Jsp的七个动作指令\"></a>Jsp的七个动作指令</h1><h2 id=\"1）jsp-include-指令\"><a href=\"#1）jsp-include-指令\" class=\"headerlink\" title=\"1）jsp:include 指令\"></a>1）jsp:include 指令</h2><p>用于请求处理阶段包含一个servlet或jsp页面的响应。和编译指令中的include不同，include只能包含静态页面，而jsp:include指令可以包含静态和动态页面。</p>\n<pre><code>#静态页面\n&lt;jsp:include page=&quot;文件路径&quot;/&gt;\n#动态页面\n&lt;jsp:include page=&quot;文件路径&quot;&gt;\n...\n&lt;/jsp:include&gt;\n</code></pre><h2 id=\"2-jsp-forword指令\"><a href=\"#2-jsp-forword指令\" class=\"headerlink\" title=\"2)jsp:forword指令\"></a>2)jsp:forword指令</h2><p>用于执行页面转向，将请求的处理转发到下一页面。</p>\n<pre><code>#跳转向静态页面\n&lt;jsp:forword page=&quot;文件路径&quot;/&gt;\n#跳转向动态页面\n&lt;jsp:forword page=&quot;文件路径&quot;&gt; \n...\n&lt;/jsp:forword&gt;\n</code></pre><h2 id=\"3-jsp-useBean指令\"><a href=\"#3-jsp-useBean指令\" class=\"headerlink\" title=\"3)jsp:useBean指令\"></a>3)jsp:useBean指令</h2><p>用于在jsp页面内创建一个JavaBean实例。</p>\n<pre><code>&lt;jsp:userBean id=&quot;JavaBean的名字&quot; scope=&quot;有效范围&quot; class=&quot;包名.类名&quot;&gt;&lt;jsp:userBean&gt;       \n</code></pre><h2 id=\"4-jsp-setProparty指令\"><a href=\"#4-jsp-setProparty指令\" class=\"headerlink\" title=\"4)jsp:setProparty指令\"></a>4)jsp:setProparty指令</h2><p>用来设置Bean对象的属性</p>\n<pre><code>&lt;jsp:setProparty name=&quot;JavaBean的名称&quot; proparty=&quot;属性名&quot;/&gt;\n&lt;jsp:setProparty name=&quot;JavaBean的名称&quot; proparty=&quot;属性名&quot; param=&quot;参数名&quot;/&gt;\n&lt;jsp:setProparty name=&quot;JavaBean的名称&quot; proparty=&quot;属性名&quot; value=&quot;参数名&quot;/&gt;\n</code></pre><h2 id=\"5-jsp-getProparty指令\"><a href=\"#5-jsp-getProparty指令\" class=\"headerlink\" title=\"5)jsp:getProparty指令\"></a>5)jsp:getProparty指令</h2><p>用来读取Bean对象的属性，并将其转换为一个字符串显示在页面上。</p>\n<pre><code>&lt;jsp:getProparty name=&quot;Bean的名称&quot; proparty=&quot;属性名称&quot;&gt;\n</code></pre><h2 id=\"6-jsp-plugin指令（不常用）\"><a href=\"#6-jsp-plugin指令（不常用）\" class=\"headerlink\" title=\"6)jsp:plugin指令（不常用）\"></a>6)jsp:plugin指令（不常用）</h2><p>用于下载服务器端的JavaBean或Applet到客户端执行。</p>\n<h2 id=\"7）jsp-param指令（不常用）\"><a href=\"#7）jsp-param指令（不常用）\" class=\"headerlink\" title=\"7）jsp:param指令（不常用）\"></a>7）jsp:param指令（不常用）</h2><p>用于设置参数，不能单独使用，主要用在jsp:inclde jsp:forword jsp:plugin指令中。</p>\n<h2 id=\"include指令与include动作\"><a href=\"#include指令与include动作\" class=\"headerlink\" title=\"include指令与include动作\"></a>include指令与include动作</h2><h3 id=\"1）include指令：\"><a href=\"#1）include指令：\" class=\"headerlink\" title=\"1）include指令：\"></a>1）include指令：</h3><p>include可以在JSP页面转换成Servlet之前，将JSP代码插入其中。它的主要优点是功能强大，所包含的代码可以含有总体上影响主页面的JSP构造，比如属性、方法的定义和文档类型的设定。它的缺点是难于维护只要被包含的页面发生更改，就得更改主页面，这是因为主页面不会自动地查看被包含的页面是否发生更改。<br>include指令的语法格式如下：</p>\n<pre><code>&lt;%@include file=&quot;Relative Url&quot;%&gt;\n</code></pre><h3 id=\"2）include动作：\"><a href=\"#2）include动作：\" class=\"headerlink\" title=\"2）include动作：\"></a>2）include动作：</h3><p>jsp:include动作是在主页面被请求时，将次级页面的输出包含进来。尽管被包含的页面的输出中不能含有JSP，但这些页面可以是其他资源所产生的结果。服务器按照正常的方式对指向被包含资源的URL进行解释，因而这个URL可以是Servlet或JSP页面。服务器以通常的方式运行被包含的页面，将产生的输出放到主页面中，这种方式与RequestDispatcher类的include方法一致。它的优点是在被包含的页面发生更改时，无须对主页面做出修改。它的缺点是所包含的是次级页面的输出，而非次级页面的实际代码，所以在被包含的页面中不能使用任何有可能在整体上影响主页面的JSP构造。<br>jsp:include动作的完整语法如下：</p>\n<pre><code>&lt;jsp:include page=&quot;Relative path to resource&quot; flush=&quot;true&quot;&gt;  \n</code></pre><h3 id=\"两者区别：\"><a href=\"#两者区别：\" class=\"headerlink\" title=\"两者区别：\"></a>两者区别：</h3><p>jsp:include动作和include指令之间的根本性的不同在于它们被调用的时间。jsp:include动作在请求期间被激活，而include指令在页面转换期间被激活。<br> 两者之间的差异决定着它们在使用上的区别。使用include指令的页面要比使用jsp:include动作的页面难于维护。使用JSP指令，如果包含的JSP页面发生变化，那么用到这个页面的所有页面都需要手动更新。在JSP服务器的相关规范中并没要求能够检测出包含的文件什么时候发生改变，实际上大多数服务器页都有去实现这种机制。这样就会导致十分严重的维护问题，需要记住所有包含某一个页面的其他页面，或者重新编译所有的页面，以使更改能够生效。在这点上，jsp:include就体现出了十分巨大的优势，它在每次请求时重新把资源包含进来。在实现文件包含上，应该尽可能地使用jsp:include动作。 </p>\n","categories":[{"name":"笔记","path":"api/categories/笔记.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"},{"name":"javaweb","path":"api/tags/javaweb.json"},{"name":"Jsp","path":"api/tags/Jsp.json"}]}